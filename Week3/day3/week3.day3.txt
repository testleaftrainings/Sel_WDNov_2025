Today's Agenda:

10:00 to 11:00 ---> Abstraction
11:00 to 11:30 ---> Activity + Break
11:30 to 12.40 ---> List
12.40 to 01:00 ---> Implicitly wait










<----------------------------------------------------------->
Overloading: 

- It refers to the ability to create multiple methods of the same name with different implementations. 
-Calls to an overloaded method will run a specific implementation of that method appropriate to the context, based on the number and type of arguments passed.

Java Examples:

Methods like accountCredits() can be overloaded to accept different types of arguments.
Similarly, substring() in the String class is overloaded to accept different starting and ending points for the substring.
println()

Selenium WebDriver Examples:

The frame() method in Selenium WebDriver is overloaded to allow different types of arguments like an integer (index of the frame), a String (name or ID of the frame), or a WebElement.

Advantages of Overloading:

Flexibility: Allows methods to handle different data types and numbers of arguments.
Readability: It can make the code more readable since the same method name can be used for similar actions on different types of input.
Reduces Complexity: Developers can use the same method name to perform similar actions, which simplifies code organization and maintenance.
Overriding

<----------------------------------------------------------->
Method overriding:-

Method overriding in Java occurs when a subclass has a method with the same name, return type, and parameters as a method in its superclass.
It's a key feature of runtime polymorphism and allows a subclass to provide a specific implementation for a method that is already provided by its parent class

Examples:

equals() of String class is overriden from the Object class
toString() of String class is overriden from the Object class
quit() of ChromiumDriver is overriden from the RemoteWebDriver Class

Super Keyword :

super has two general forms. The first calls the superclass‚Äô constructor. The second is 
used to access a member of the superclass that has been hidden by a member of a subclass.



*******************************************************************
Abstraction:

Definition:

Abstraction is an OOPs concept that focuses on hiding complex implementation details and exposing only the necessary parts of an object. It's about representing features without including background details.

Advantages of Abstraction:

Simplicity: Abstraction simplifies the view of an object, so you don't need to understand the 
internal workings to use it.
Reusability: Abstract classes and interfaces can be reused to implement common methods in 
multiple subclasses.

Keyword: The "implements" keyword is used to implement an Interface

*************************************************************************
syntax :

accessModifier interface name { 
return-type method-name1(parameter-list); 
return-type method-name2(parameter-list); 
type final-varname1 = value; 
type final-varname2 = value; 
}       




In Java, variables declared inside an interface behave differently compared to those in a normal class.

üëâ By default, every variable declared inside an interface is automatically:

public , static , final

Even if you don‚Äôt write those keywords, Java adds them for you behind the scenes!

üëâWhat does that mean practically?

public:  All methods and variables are implicitly public.The variable can be accessed by any class that can see the interface.

static: The variable belongs to the interface itself, not to instances of implementing classes.

final: The variable is a constant ‚Äî once assigned, it cannot be changed.

üëâWhy is it designed this way?

Interfaces are contracts ‚Äî they define what must be done.

Constants (public static final variables) are part of that contract: they are shared facts that implementations can rely on.

Java wanted to keep interfaces pure: no state or instance-specific data inside them.
(Remember, interfaces are not supposed to "store" things.)


****************************************************************************
Java‚Äôs interfaces were originally purely abstract contracts‚Äîjust method signatures‚Äîso adding any new method to an interface would break all existing implementors. Java 8 loosened that strict rule by allowing two special kinds of concrete methods:

default methods

Why? To let library designers evolve interfaces over time without forcing everybody to update their code.

Example: The Collection interface got a new stream() method in Java 8. By making it a default method (with a built-in implementation), all your old List, Set, etc. classes automatically ‚Äúinherit‚Äù that behavior‚Äîyou don‚Äôt have to go back and implement stream() everywhere.

static methods

Why? To group related helper or utility methods right next to the interface they serve, instead of scattering them in separate utility classes (like Collections, Objects, etc.).

Example: Map.of(...) is a static factory on the Map interface itself. It reads more naturally than Collections.mapOf(...), and it‚Äôs impossible for an implementing class to accidentally override it.

-------------------------------------------------------------------------------
step 1: Right click on the package---> new ---> interface
step 2: create the java class ()
step 3: if the java class want to share the properties of interface means which keyword should be used ?
implements

optional (works only on JKD Version 8 or above)
step 4: create a implemented method inside the interface
---> static 
---> default




the properties of interface:-
	//unimplemented method
	public void kyc();
	//unimplemented method
	public void withDraw();
*************************************************************************

Types:

Interfaces: Used for full abstraction, they cannot have any implementation.100%
Abstract Classes: Provide partial abstraction with some implemented methods.both implemented ,unimplemented
Concrete Classes: Regular classes with full implementation.

Java Examples:

Interfaces: List, Set, Map are interfaces providing a standard set of methods to be 
implemented by concrete collections.

Abstract Classes: AbstractList, AbstractCollection provide skeletal implementations that 
can be used as starting points for creating concrete collections.

Selenium WebDriver Examples:

Interfaces: WebDriver, WebElement, Alert are interfaces representing abstract concepts in browser automation.
Abstract Classes: By is an abstract class providing methods to locate elements.
Concrete Classes: RemoteWebDriver is a concrete implementation of the WebDriver interface.

KeyWords
===========
Class to Interface: -implements
abstract class to Interface: - implements
class to abstract class:  - extends
class to class: - extends
interface to interface: - extends 







-------------------------------------------------------------------------------


Queue & Deque (FIFO or LIFO)

A)Queue ‚Äì FIFO (First-In-First-Out) order.
Example: LinkedList, PriorityQueue (orders based on priority).

B)Deque ‚Äì Can be FIFO or LIFO(Last-In-First-Out).
Example: ArrayDeque, LinkedList.

-----------------------
List Interface in Java:

Here are some key characteristics and methods associated with the List interface:

1. Ordered Collection:
   - Lists maintain the order in which elements are inserted. The order of elements in a list is determined by the sequence in which they were added.

2. Duplicates Allowed:
   - List allows duplicate elements. Each element in the list has a unique index, starting from 0.

3. Dynamic Size:
   - Lists can dynamically grow or shrink in size as elements are added or removed. The size of a list is not fixed.

4. Common List Implementations:
   - ArrayList: Implements a dynamic array that can grow or shrink in size. Provides fast random access and is suitable for scenarios where elements are frequently accessed.
   - LinkedList: Implements a doubly-linked list. Provides efficient insertion and deletion of elements at any position in the list.

wrapper class : specifically designed to wrap primitive data types
EX:
dataType -  wrapper class
============================
int      -  Integer
double   -  Double


5. Common Methods:
   - add: Adds an element to the list.
üëâAdding Items (add() method):

Usage: To add elements to the list.
Real-time Use Case: This is used when you need to add new data to your collection. For example, adding new members to a project team or new items to a to-do list.

üëâInserting at Specific Index (add(index, element)):

Usage: To add an element at a specified position in the list.
Real-time Use Case: Useful in cases where the order is important, like adding a new task at a specific position in a task list or inserting a new chapter into a specific position in a book's table of contents.

üëâAdding All Elements from Another List (addAll()):

Usage: To add all elements from one list into another.
Real-time Use Case: Merging two datasets, such as combining two lists of customers from different regions into a single list for a unified analysis.

   - get: Retrieves the element at a specified index.
üëâAccessing Elements (get(index)):

Usage: To retrieve a specific element from the list based on its index.
Real-time Use Case: Fetching a specific data entry, such as retrieving a specific order detail from a list of orders.

   - remove: Removes an element from the list.
üëâRemoving Elements (remove(index) and removeAll()):

Usage: remove(index) removes an element at a specific index, while removeAll() removes all elements that are present in another collection.
Real-time Use Case: remove(index) can be used for deleting a specific entry, like removing a discontinued product from a product list. removeAll() can be useful in filtering out data, like removing all outdated items from a current inventory list.

üëâClearing the List (clear()):

Usage: To remove all elements from the list, making it empty.
Real-time Use Case: Resetting data, such as clearing a user's shopping cart after they have completed the checkout process.



   - size: Returns the number of elements in the list.
üëâFinding the Size of the List (size() method):

Usage: To get the number of elements in the list.
Real-time Use Case: Checking the number of entries in a database, like the number of students enrolled in a course or the number of items in stock.

   - contains: Checks if a specific element is present in the list






***********************************************************************
Definition: 

The List interface in Java is part of the Java Collections Framework. 
It represents an ordered collection (also known as a sequence). 
Lists can contain duplicate elements and are dynamic in size, meaning they can grow or shrink as needed.

1)Why Use Lists: 
	Lists are used when you need an ordered collection that can change in size. 
	This is particularly useful when you don't know the number of elements in advance, or when you need to perform frequent insertions and deletions.

2)ArrayList vs LinkedList: 
	While ArrayList is the most common implementation, providing fast access and efficient storage for large numbers of elements, LinkedList can be more 	efficient for certain use cases, especially where frequent insertion and deletion occur.

1. ArrayList üìö
What it is: A dynamic array that grows as you add more items.

Real-world use: Think of it like a shopping list. You can add, remove, or check items easily.

Real-World Example: A Bookshelf

You can add or remove books at any position.

Want the 5th book? Just count and grab it!


2. LinkedList üîó
What it is: A list where each item is connected to the next (like a chain).

Real-world use: Imagine a line of people waiting for a bus. You can easily add or remove someone from the line.

Real-World Example: Train Carriages üöÑ

Each carriage is linked to the next. Add/remove carriages easily, but finding the 10th carriage takes time!

Methods and Use Cases:

Creating Lists (new ArrayList<>()):
Usage: To initialize a list.
Real-time Use Case: In a real-world scenario, you might initialize a list to store data such as employee names, product details, or any collection of similar items. 
For example, a list to store the names of participants in a workshop.


üëâPrinting the List (System.out.println(list)):

Usage: To display the contents of the list.
Real-time Use Case: Displaying a list of items, such as a list of available products to a user, or printing a list of registered participants for an event.


üî§ Lexicographic Sorting (Dictionary Order)
Lexicographic order is how words are arranged in a dictionary ‚Äî based on character-by-character comparison, starting from the leftmost character.

It does not care about the numeric value, only about character values (ASCII/Unicode).

ex:
List<String> prices = Arrays.asList("900", "1200", "50", "300");
Collections.sort(prices);
System.out.println(prices);

‚ùå Output (Lexicographic):
[1200, 300, 50, 900]

‚û°Ô∏è Lexicographically, "1" < "3" < "5" < "9" ‚Üí so it sorts based on this.

So "1200" comes before "300", even though numerically 1200 > 300.


üî¢ Numeric Sorting (What You Actually Want)

You compare the actual numeric values, not characters.

To get correct sorting:

List<String> prices = Arrays.asList("900", "1200", "50", "300");

prices.sort(Comparator.comparingInt(Integer::parseInt));
System.out.println(prices);


‚úÖ Output (Numeric Sort):

[50, 300, 900, 1200]




